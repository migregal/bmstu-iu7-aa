\chapter{Экспериментальная часть}

В данном разделе будет проведено функциональное тестирование разработанного программного обеспечения. Так же будет произведено измерение временных характеристик каждого из реализованных алгоритмов. 

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось исследование:

\begin{itemize}
	\item Процессор: Intel Core™ i5-8250U \cite{i5} CPU @ 1.60GHz.
	\item Память: 32 GiB.
	\item Операционная система: Manjaro \cite{manjaro} Linux \cite{linux} 21.1.4 64-bit.

\end{itemize}

Исследование проводилось на ноутбуке, включенном в сеть электропитания. Во время тестирования ноутбук был нагружен только встроенными приложениями окружения рабочего стола, окружением рабочего стола, а также непосредственно системой тестирования.

\section{Временные характеристики}

Так как в реализуемом конвейере реализуются \texttt{fan-out} и \texttt{fan-in} подходы, особый интерес представляет зависимость временных характеристик системы от количества параллельных сопрограмм.

Для сравнения возьмем конвейеры с соответствующим числом сопрограмм из набора [1, 2, 4, 8, \dots, 64].

На момент тестирования в файловой системе машины, на которой проводились тесты, насчитывалось 23447250 файлов различного типа и размера. В ходе проведения эксперимента данная величина оставалась неизменной.

Так как в общем случае вычисление хеш-суммы файла является достаточно короткой задачей, воспользуемся усреднением массового эксперимента.  Для этого вычислим среднее арифметическое значение временных ресурсов, затраченных на выполнение алгоритма, для $n$ запусков. Сравнение произведем при $n = 100$.

В первую очередь, интерес представляет временные характеристики реализованного конвейера, в сравнении с линейной реализацией алгоритма. В качестве временных характеристик линейной реализации примем общее время, которое задачи находились в процессе обработки конвейером (т.е. суммарное время простоя и обработки на каждой из лент конвейера).

Результаты замеров по результатам экспериментов приведены в Таблице \ref{tbl:time_total}.

\begin{table}[ht]
	\small
	\begin{center}
		\caption{Сравнение общего и реального времени выполнения алгоритма}
		\label{tbl:time_total}
		\begin{tabular}{|c|c|c|}
			\hline
			\bfseries Количество & \bfseries Общее время & \bfseries Реальное время\\ 
			\bfseries сопрограмм, шт. & \bfseries работы системы, нс & \bfseries работы системы, нс
			\csvreader{inc/csv/time.csv}{}
			{\\\hline \csvcoli&\csvcolii&\csvcoliii}
			\\\hline
		\end{tabular}
	\end{center}
\end{table}

Из данных, приведенных в таблице \ref{tbl:time_total}, модно сделать вывод, что конвейерная организация вычислений является более эффективной, чем линейная (вплоть до двух порядков, при количестве сопрограмм равном 64).

Отдельно стоит отметить факт того, что, при запуске всего одной сопрограммы, общее время работы в двое превосходит реальное время работы конвейера. Такой результат является ожидаемым, так как, с ростом числа задач, обрабатываемых конвейером, пропорционально увеличивается общее время ожидания и простоя.

На Рисунке \ref{plt:time_total} отображены временные зарактеристики работы конвейера из Таблицы \ref{tbl:time_total}.

\begin{figure}[!ht]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			axis lines=left,
			xmin=1, xmax=64,
			xtick={1,2,4,8,16,32,64},
			xlabel={Количество сопрограмм},
			ylabel={Время выполнения, нс},
			legend pos=north east,
			ymajorgrids=true
		]
			\addplot table[x=threads,y=totaltime,col sep=comma] {inc/csv/time.csv};
			\addplot table[x=threads,y=realtime,col sep=comma] {inc/csv/time.csv};
			\legend{Общее, Реальное}
		\end{axis}
	\end{tikzpicture}
	\captionsetup{justification=centering}
	\caption{Сравнение общего и реального времени выполнения алгоритма}
	\label{plt:time_total}
\end{figure}

Из Рисунка \ref{tbl:time_total} следует, что, несмотря на увеличивающеесф общее время выполнения алгоритма, реальное время выполнения алгоритма уменьшается (вплоть до 3 раз при увелечении от 1 до 64 сопрограмм).

Так как сопрограммы в языке программирование \texttt{golang} реализуются в рамках одного потока, максимальная производительность конвейера достигается при значениях больших количества логических ядер конкретной машины.

Отдельно сравним среднее время выполнения каждой из стадий конвейера. Данные, полученные в ходе эксперимента, приведены в Таблице \ref{tbl:time_avg}. Т.к. третья лента конвейера является завершающей, остальные ленты не оказывают влияния на время обработки ею задачи. В связи с этим, среднее время обработки задачи третьей лентой будет исключено из сравнения.

\begin{table}[ht]
	\small
	\begin{center}
		\caption{Среднее время выполнения различных стадий конвейера}
		\label{tbl:time_avg}
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			\bfseries Количество & \multicolumn{4}{c|}{\bfseries Среднее время}\\ \cline{2-5}
			\bfseries сопрограмм, шт. & \bfseries Лента 1, нс & \bfseries Очередь 2, нс& \bfseries Лента 2, нс & \bfseries Очередь 3, нс
			\csvreader{inc/csv/time.csv}{}
			{\\\hline \csvcoli&\csvcoliv&\csvcolv&\csvcolvi&\csvcolvii}
			\\\hline
		\end{tabular}
	\end{center}
\end{table}

Из таблицы \ref{tbl:time_avg} следует, что, с ростом числа сопрограмм, растёт среднее время выполнения каждой из стадий конвейера. Это связано с дополнительными затратами из-за многопоточной реализации второй ленты конвейера.

На Рисунке \ref{plt:time_avg} отображены усредненные временные харкатеристики выполнения каждой из стадий конвейера.

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			axis lines=left,
			xmin=1, xmax=64,
			xtick={1,4,8,16,64},
			xlabel={Размер массива, элементов},
			ylabel={Процессорное время, тиков},
			legend pos=north west,
			ymajorgrids=true
		]
			\addplot table[x=threads,y=avg_filewalker,col sep=comma] {inc/csv/time.csv};
			\addplot table[x=threads,y=avg_digester,col sep=comma] {inc/csv/time.csv};
			\addplot table[x=threads,y=avg_queue_1,col sep=comma] {inc/csv/time.csv};
			\addplot table[x=threads,y=avg_queue_2,col sep=comma] {inc/csv/time.csv};
			\legend{Лента 2, Лента 3, Очередь 2, Очередь 3}
		\end{axis}
	\end{tikzpicture}
	\captionsetup{justification=centering}
	\caption{Усредненные временные харкатеристики выполнения каждой из стадий конвейера}
	\label{plt:time_avg}
\end{figure}

Из Рисунка \ref{plt:time_avg} следует, что увеличивается не только время ожидания в очереди, но и время обработки задачи конкретной лентой конвейера. Связано это с синхронной реализацией конвейера - очереди между лентами являются небуффероизированными, т.е. пропускают лишь одну задачу за раз, блокируя остальные ленты.

В связи с ростом числа сопрограмм, \texttt{Очередь 3} становится так называемым "бутылочным горлышком" конвейера. Для решения этой проблемы используюся очереди динамической размерности (в процессе выполнения программы они могут расширяться, чтобы хранить большее число задач, не приводя к блокировке остальных стадий конвейера).

В Таблице \ref{tbl:time_log} представлена временная трассировка выполнения для первых шести задач в конвейере. Прочерк означает, что данная задача не обрабатываласб указанной лентой. Такой результат является корректным, например, для директории - хеш-сумма может быть вычислена только у файла, в связи с чем, обрабатывать директорию на второй и третьей ленте бессмысленно.

\begin{table}[ht]
	\small
	\begin{center}
		\caption{Среднее время выполнения различных стадий конвейера}
		\label{tbl:time_log}
		\begin{tabular}{|c|c|c|c|}
			\hline
			\bfseries Лента & \bfseries Задача & \bfseries Начало, с & \bfseries Конец, с
			\csvreader{inc/csv/sequence.csv}{}
			{\\\hline \csvcoli&\csvcolii&\csvcoliii&\csvcoliv}
			\\\hline
		\end{tabular}
	\end{center}
\end{table}

Из данных, приведенных в Таблице \ref{tbl:time_log} следует, что обработка задач действительно происходит асинхронно - во время работы одной ленты, другие выполняют свои функции. Кроме того, видно, что в данной конфигурации конвейера при малом количестве задач в конвейере (в данном случае - шесть) не возникают простои каких-дибо лент.

\section{Вывод}
В данном разделе было произведено эксперементальное исследование количества затраченного вре­мени вышеизложенным алгоритмом.

Наиболее эффективной оказалась реализация конвейера с большим (64 шт.) числом сопрограмм в рамках третей ленты. Несмотря на увеличение времени простоя системы (в 10 раз, в сравнении с реализацией с 1 сопрограммой), реальное время работы конвейера снизилось в 3 раза (в сравнении с реализацией с 1 сопрограммой).

Для оптимизации существующейго решения стоит использовать очереди динамической размерности, чтобы предотвратить блокировку частей конвейера друг другом. Т.к. такая реализация потребует дополнительных затрат памяти, следует использовать конвейер с фиксированным размером очереди между лентами в тех случаях, когда существуют жесткие ограничения по памяти.